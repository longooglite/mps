# [Copyright]
# SmartPath v1.0
# Copyright 2014-2015 Mountain Pass Solutions, Inc.
# This unpublished material is proprietary to Mountain Pass Solutions, Inc.
# [End Copyright]

import operator
import monthdelta

import MPSCore.utilities.dateUtilities as dateUtils
from MPSAppt.services.abstractTaskService import AbstractTaskService
import MPSAppt.core.sql.rosterSQL as rosterSQL
import MPSAppt.services.lookupTableService as lookupSvc
import MPSAppt.services.jobActionService as jobactionSvc
import MPSCore.utilities.stringUtilities as stringUtils
import MPSAppt.services.departmentService as deptSvc

#   Get/massage Roster data.
#   There are two primary (public) methods:
#       getRoster():        builds and returns a verbose List of entries to display on the Roster
#       trimRoster(roster): removes cruft from the List generated by getRoster()
#                           the intent here is to strip the roster down to just what's necessary for display,
#                           avoiding transmission of unused data to the browser

class RosterService(AbstractTaskService):
	def __init__(self, _connection, _profile):
		AbstractTaskService.__init__(self, _connection)
		self.profile = _profile
		#   Various internal lookup data caches.

		self.titleCache = lookupSvc.getLookupTable(self.connection, 'wf_title')
		self.trackCache = lookupSvc.getLookupTable(self.connection, 'wf_track')
		self.metaTrackCache = lookupSvc.getLookupTable(self.connection, 'wf_metatrack')
		self.departmentCache = deptSvc.DepartmentService(self.connection).getAllDepartmentsAsLookupTable()
		self.statusCache = lookupSvc.getLookupTable(self.connection, 'wf_appointment_status')
		self.statusByCodeCache = lookupSvc.getLookupTable(self.connection, 'wf_appointment_status', _key='code')
		self.workflowCache = lookupSvc.getLookupTable(self.connection, 'wf_workflow')
		self.jobActionTypeCache = lookupSvc.getLookupTable(self.connection, 'wf_job_action_type')
		self.jobActionSvc = jobactionSvc.JobActionService(_connection)
		self.departmentList = []
		#   IDs for FILLED and INPROGRESS Appointment Statuses.

		self.filledStatusId = self.statusByCodeCache.get('FILLED', 0)['id']
		self.inprogressStatusId = self.statusByCodeCache.get('INPROGRESS', 0)['id']


		#   Caches used during processing.

		#   pcnCache
		#   Dictionary of all PCNs.
		#       key = pcn
		#       value = dictionary of PCN-related crap

		self.pcnCache = {}

		#   personCache
		#   Dictionary of Persons and their associated PCNs.
		#       key = personId
		#       value = list of associated PCNs

		self.personCache = {}


		#   allowedDepts
		#   Dictionary of Department Codes to which the user has been given access.
		#   Constructed in the getRoster() method, where a username has been provided.
		#       key = department code
		#       value = True

		self.allowedDepts = {}

	def _initProcessCaches(self):
		self.pcnCache = {}
		self.personCache = {}


	#   Main method to generate Roster data.
	#   Returns a List of dictionaries, sorted by (Primary) PCN.

	def getRoster(self, _community=None, _username=None):
		self._initProcessCaches()

		rawData = rosterSQL.getRawRosterData(self.connection)
		self._phase1_IdentifyPCNs(rawData)
		self._phase2_FillPositions(rawData)
		self._phase3_ApplyJobActions(rawData)
		self._phase4_matchSecondariesToPrimary(rawData)
		self._phase5_DepartmentScreen(rawData, _community, _username)
		if self.pcnCache:
			return sorted(self.pcnCache.values(), key=operator.itemgetter('pcn'))
		return []


	#   Primary worker routines for the main method.

	def _phase1_IdentifyPCNs(self, rawData):

		#   Resolve Foreign Keys
		#   Fill pcnCache with all PCNs, both Primary and Secondary.

		for rowDict in rawData:
			self._resolveForeignKeys(rowDict)
			thisPCN = rowDict.get('pcn', '')
			if (thisPCN) and (not thisPCN in self.pcnCache):
				self.pcnCache[thisPCN] = self._initializePcnDict(rowDict)

	def _phase2_FillPositions(self, rawData):

		#   Identify the Person in-seat (if any) for all Positions.
		#   Fill personCache with persons and their associated PCNs:
		#       key = personId
		#       value = list of associated PCNs

		for rowDict in rawData:
			apptDict = self._initializeAppointmentDict(rowDict)

			appointmentStatusId = rowDict.get('appointment_status_id', None)
			isFilled = (appointmentStatusId == self.filledStatusId)
			if isFilled:
				self._getFilledAppointmentDict(apptDict, rowDict)
			else:
				self._getVacantAppointmentDict(apptDict, rowDict)

			#   Put the apptDict on the Primary PCN.
			thisPCN = rowDict.get('pcn', '')
			apptList = self.pcnCache.get(thisPCN,{}).get('appointment_list',[])
			if not apptList:
				apptList.append(apptDict)

				#   Remember people for Filled Primary positions in the personCache.
				if (isFilled) and (rowDict.get('is_primary', False)):
					personId = apptDict.get('person_id', None)
					if (personId) and (not personId in self.personCache):
						self.personCache[personId] = thisPCN

	def _phase3_ApplyJobActions(self, rawData):

		#   Apply In-Progress Job Actions.

		for rowDict in rawData:
			appointmentStatusId = rowDict.get('appointment_status_id', None)
			if appointmentStatusId == self.inprogressStatusId:
				jobActionDict = self._initializeJobActionDict(rowDict)
				self._getJobActionDict(jobActionDict, rowDict)

				apptDict = self._initializeAppointmentDict(rowDict)
				self._getFilledAppointmentDict(apptDict, rowDict)
				apptDict['job_action_list'].append(jobActionDict)

				pcnDict = self.pcnCache[rowDict.get('pcn',{})]
				pcnDict['appointment_list'].append(apptDict)

	def _phase4_matchSecondariesToPrimary(self, rawData):
		pcnDeleteList = []
		for pcn in sorted([k for k in self.pcnCache.keys()]):
			pcnDict = self.pcnCache[pcn]
			if not pcnDict['is_primary']:
				appointmentList = pcnDict.get('appointment_list', [])
				if appointmentList:
					firstAppointmentDict = appointmentList[0]
					personId = firstAppointmentDict.get('person_id', 0)
					if (personId) and (personId in self.personCache):
						primaryPCN = self.personCache[personId]
						primaryPcnDict = self.pcnCache.get(primaryPCN, None)
						if primaryPcnDict:
							primaryPcnDict.get('appointment_list',[]).extend(pcnDict.get('appointment_list',[]))
							pcnDeleteList.append(pcn)

		for pcn in pcnDeleteList:
			del self.pcnCache[pcn]

	def _phase5_DepartmentScreen(self, rawData, _community, _username):

		#   Remove data for Departments not accessible to the given User.
		#   Mark PCNs as actionable by this end-user, or not.

		if not _username:
			return

		self._getAllowedDepartmentsCache(_community, _username)
		if not self.departmentList:
			self.pcnCache = []
			return
		allOverrides = self.jobActionSvc.getAllOverridesForDepartmentList(self.departmentList)
		pcnList = [k for k in self.pcnCache.keys()]
		for pcn in pcnList:
			pcnDict = self.pcnCache[pcn]
			if pcnDict:
				thisPCNAllowed = False
				foundActionableAppt = False
				for apptDict in pcnDict.get('appointment_list', []):
					thisDeptCode = apptDict.get('department_code','')
					if thisDeptCode in self.allowedDepts:
						apptDict['actionable'] = True
					else:
						apptDict['actionable'] = self._hasOverrideAccessToJobAction(apptDict.get('jobaction_id',0),allOverrides)
					thisPCNAllowed = True if apptDict['actionable'] else False
					if thisPCNAllowed:
						foundActionableAppt = True
				if not thisPCNAllowed and not foundActionableAppt:
					del self.pcnCache[pcn]

	def _hasOverrideAccessToJobAction(self,_jobActionId,_allOverrides):
		if _allOverrides:
			for override in _allOverrides:
					if override.get('job_action_id',-1) == _jobActionId:
						return override.get('access_allowed',False)
		return False

	def _getAllowedDepartmentsCache(self, _community, _username):
		self.departmentList = deptSvc.DepartmentService(self.connection).getDepartmentsForUser(_community, _username)
		deptList = {}
		for deptDict in self.departmentList:
			deptList[deptDict.get('code','')] = True
		self.allowedDepts = deptList


	#   Dictionary initializations.

	def _initializePcnDict(self, _rowDict):
		pcnDict = {}
		pcnDict['pcn'] = _rowDict.get('pcn', '')
		pcnDict['pcn_url'] = self._getPcnUrl(_rowDict)
		pcnDict['position_id'] = _rowDict.get('position_id', '')
		pcnDict['is_primary'] = _rowDict.get('is_primary', True)
		pcnDict['department_code'] = _rowDict.get('department_code', '')
		pcnDict['department_descr'] = _rowDict.get('department_descr', '')
		pcnDict['department_id'] = _rowDict.get('department_id', -1)
		pcnDict['appointment_list'] = []
		return pcnDict

	def _initializeAppointmentDict(self, _rowDict):
		apptDict = self._initializeSubrow(_rowDict)
		appointmentId = _rowDict.get('appointment_id',0)
		apptDict['appointment_id'] = appointmentId
		apptDict['actionable'] = True
		apptDict['job_action_list'] = []
		apptDict['jobaction_id'] = _rowDict.get('job_action_id',0)
		return apptDict

	def _initializeJobActionDict(self, _rowDict):
		jobActionDict = self._initializeSubrow(_rowDict)
		return jobActionDict

	def _initializeSubrow(self, _rowDict):
		subrow = {}
		subrow['pcn'] = _rowDict.get('pcn', '')
		subrow['pcn_url'] = self._getPcnUrl(_rowDict)
		subrow['position_id'] = _rowDict.get('position_id', '')
		subrow['is_primary'] = _rowDict.get('is_primary', True)
		subrow['department_code'] = _rowDict.get('department_code', '')
		subrow['department_descr'] = _rowDict.get('department_descr', '')
		subrow['status_code'] = _rowDict.get('status_code', '')
		subrow['status_descr'] = _rowDict.get('status_descr', '')
		return subrow


	#   Filling dictionaries with data.

	def _getFilledAppointmentDict(self, _apptDict, _rowDict):
		_apptDict['title_code'] = _rowDict.get('appointment_title_code', '')
		_apptDict['title_descr'] = _rowDict.get('appointment_title_descr', '')
		_apptDict['track_code'] = _rowDict.get('appointment_track_code', '')
		_apptDict['track_descr'] = _rowDict.get('appointment_track_descr', '')
		_apptDict['metatrack_code'] = _rowDict.get('appointment_metatrack_code', '')
		_apptDict['metatrack_descr'] = _rowDict.get('appointment_metatrack_descr', '')
		_apptDict['metatrack_supplemental'] = _rowDict.get('appointment_metatrack_supplemental', False)

		_apptDict['start_date'] = _rowDict.get('start_date', '')
		_apptDict['time_in_rank_display'],_apptDict['time_in_rank_months'] = self.calculateTimeInRank(_apptDict['start_date'])

		_apptDict['end_date'] = _rowDict.get('end_date', '')

		personId = _rowDict.get('person_id', 0)
		_apptDict['person_id'] = personId
		_apptDict['person_url'] = ''
		if personId:
			_apptDict['username'] = _rowDict.get('username', '')
			_apptDict['first_name'] = _rowDict.get('first_name', '')
			_apptDict['middle_name'] = _rowDict.get('middle_name', '')
			_apptDict['last_name'] = _rowDict.get('last_name', '')
			_apptDict['suffix'] = _rowDict.get('suffix', '')
			_apptDict['email'] = _rowDict.get('email', '')
			_apptDict['display_name'] = _rowDict.get('display_name', '')
			_apptDict['person_url'] = self._getPersonUrl(_rowDict)

	def calculateTimeInRank(self,_start_date):
		tir = ''
		totalMonths = None
		try:
			if _start_date:
				then = dateUtils.parseUTCDateOnly(_start_date)
				now = dateUtils.parseUTCDateOnly(dateUtils.formatUTCDateOnly())
				delta = monthdelta.monthmod(then,now)
				months = delta[0].months
				totalMonths = months
				if months > 11:
					months = totalMonths
					years = months/12
					months -= years*12
					tir = '%iy ' % (years)
				tir += '%im' % (months)
		except Exception,e:
			pass
		finally:
			return tir,totalMonths

	def _getVacantAppointmentDict(self, _apptDict, _rowDict):
		_apptDict['title_code'] = _rowDict.get('position_title_code', '')
		_apptDict['title_descr'] = _rowDict.get('position_title_descr', '')
		_apptDict['track_code'] = _rowDict.get('position_track_code', '')
		_apptDict['track_descr'] = _rowDict.get('position_track_descr', '')
		_apptDict['metatrack_code'] = _rowDict.get('position_metatrack_code', '')
		_apptDict['metatrack_descr'] = _rowDict.get('position_metatrack_descr', '')
		_apptDict['metatrack_supplemental'] = _rowDict.get('position_metatrack_supplemental', False)

	def _getJobActionDict(self, _jobActionDict, _rowDict):
		_jobActionDict['title_code'] = _rowDict.get('appointment_title_code', '')
		_jobActionDict['title_descr'] = _rowDict.get('appointment_title_descr', '')
		_jobActionDict['track_code'] = _rowDict.get('appointment_track_code', '')
		_jobActionDict['track_descr'] = _rowDict.get('appointment_track_descr', '')
		_jobActionDict['metatrack_code'] = _rowDict.get('appointment_metatrack_code', '')
		_jobActionDict['metatrack_descr'] = _rowDict.get('appointment_metatrack_descr', '')
		_jobActionDict['metatrack_supplemental'] = _rowDict.get('appointment_metatrack_supplemental', False)

		_jobActionDict['job_action_updated'] = _rowDict.get('job_action_updated', '')
		if _jobActionDict['job_action_updated']:
			format = self.profile.get('siteProfile',{}).get('sitePreferences',{}).get('ymdformat','%m/%d/%Y')
			_jobActionDict['job_action_updated'] = dateUtils.parseUTCDate((_rowDict.get('job_action_updated', ''))).strftime(format)
		_jobActionDict['start_date'] = _rowDict.get('start_date', '')
		_jobActionDict['end_date'] = _rowDict.get('end_date', '')

		_jobActionDict['proposed_start_date'] = ''
		if _rowDict['proposed_start_date']:
			format = self.profile.get('siteProfile',{}).get('sitePreferences',{}).get('ymdformat','%m/%d/%Y')
			_jobActionDict['proposed_start_date'] = dateUtils.parseUTCDateOnly(_rowDict.get('proposed_start_date', '')).strftime(format)
		_jobActionDict['countdown_days'] = self.jobActionSvc.calculateCountDownDays(_jobActionDict.get('proposed_start_date',''),None,self.profile)
		_jobActionDict['workflow_id'] = _rowDict.get('workflow_id', 0)
		_jobActionDict['workflow_code'] = _rowDict.get('workflow_code', '')
		_jobActionDict['workflow_descr'] = _rowDict.get('workflow_descr', '')
		_jobActionDict['job_action_type_code'] = _rowDict.get('job_action_type_code', '')
		_jobActionDict['job_action_type_descr'] = _rowDict.get('job_action_type_descr', '')
		_jobActionDict['job_action_id'] = _rowDict.get('job_action_id', 0)
		_jobActionDict['job_action_status'] = _rowDict.get('job_action_status', '')
		_jobActionDict['job_action_url'] = self._getJobActionUrl(_rowDict)

		personId = _rowDict.get('person_id', 0)
		_jobActionDict['person_id'] = personId
		_jobActionDict['person_url'] = ''
		if personId:
			_jobActionDict['username'] = _rowDict.get('username', '')
			_jobActionDict['first_name'] = _rowDict.get('first_name', '')
			_jobActionDict['middle_name'] = _rowDict.get('middle_name', '')
			_jobActionDict['last_name'] = _rowDict.get('last_name', '')
			_jobActionDict['suffix'] = _rowDict.get('suffix', '')
			_jobActionDict['email'] = _rowDict.get('email', '')
			_jobActionDict['display_name'] = _rowDict.get('display_name', '')
			_jobActionDict['person_url'] = self._getPersonUrl(_rowDict)

	def _getPcnUrl(self, _rowDict):
		if self.hasPermission("apptPositionView"):
			return "/appt/pcn/%s" % _rowDict.get('position_id', '0')
		else:
			return ""

	def _getPersonUrl(self, _rowDict):
		if self.hasPermission("apptPositionView"):
			return "/appt/person/%s" % str(_rowDict.get('person_id', '0'))
		else:
			return ""

	def _getJobActionUrl(self, _rowDict):
		return "/appt/jobaction/%s" % str(_rowDict.get('job_action_id', '0'))

	def hasPermission(self, _permission):
		if _permission:
			for permDict in self.profile.get('userProfile',{}).get('userPermissions',{}):
				if permDict.get('code', '') == _permission:
					return True
		return False


	#   Foreign Key resolution.

	def _resolveForeignKeys(self, _rosterDict):
		_rosterDict['department_code'] = ''
		_rosterDict['department_descr'] = ''
		_rosterDict['position_title_code'] = ''
		_rosterDict['position_title_descr'] = ''
		_rosterDict['position_track_code'] = ''
		_rosterDict['position_track_descr'] = ''
		_rosterDict['position_metatrack_code'] = ''
		_rosterDict['position_metatrack_descr'] = ''
		_rosterDict['position_metatrack_supplemental'] = ''
		_rosterDict['appointment_title_code'] = ''
		_rosterDict['appointment_title_descr'] = ''
		_rosterDict['appointment_track_code'] = ''
		_rosterDict['appointment_track_descr'] = ''
		_rosterDict['appointment_metatrack_code'] = ''
		_rosterDict['appointment_metatrack_descr'] = ''
		_rosterDict['appointment_metatrack_supplemental'] = ''
		_rosterDict['status_code'] = 'VACANT'
		_rosterDict['status_descr'] = 'Vacant'
		_rosterDict['workflow_code'] = ''
		_rosterDict['workflow_descr'] = ''
		_rosterDict['job_action_type_code'] = ''
		_rosterDict['job_action_type_descr'] = ''
		_rosterDict['display_name'] = self._assignName(_rosterDict)

		departmentId = _rosterDict.get('department_id', None)
		if departmentId:
			departmentDict = self.departmentCache.get(departmentId, None)
			if departmentDict:
				_rosterDict['department_code'] = departmentDict.get('code', '')
				_rosterDict['department_descr'] = departmentDict.get('full_descr', '')

		self._resolveTitle(_rosterDict, 'position')
		self._resolveTitle(_rosterDict, 'appointment')

		statusId = _rosterDict.get('appointment_status_id', None)
		if statusId:
			statusDict = self.statusCache.get(statusId, None)
			if statusDict:
				_rosterDict['status_code'] = statusDict.get('code', '')
				_rosterDict['status_descr'] = statusDict.get('descr', '')

		workflowId = _rosterDict.get('workflow_id', None)
		if workflowId:
			workflowDict = self.workflowCache.get(workflowId, None)
			if workflowDict:
				_rosterDict['workflow_code'] = workflowDict.get('code', '')
				_rosterDict['workflow_descr'] = workflowDict.get('descr', '')
				jobActionTypeId = workflowDict.get('job_action_type_id', None)
				if jobActionTypeId:
					jobActionTypeDict = self.jobActionTypeCache.get(jobActionTypeId, None)
					if jobActionTypeDict:
						_rosterDict['job_action_type_code'] = jobActionTypeDict.get('code', '')
						_rosterDict['job_action_type_descr'] = jobActionTypeDict.get('descr', '')

	def _resolveTitle(self, _rosterDict, _prefix):
		titleId = _rosterDict.get(_prefix + '_title_id', None)
		if titleId:
			titleDict = self.titleCache.get(titleId, None)
			if titleDict:
				_rosterDict[_prefix + '_title_code'] = titleDict.get('code', '')
				_rosterDict[_prefix + '_title_descr'] = titleDict.get('descr', '')
				trackId = titleDict.get('track_id', None)
				if trackId:
					trackDict = self.trackCache.get(trackId, None)
					if trackDict:
						_rosterDict[_prefix + '_track_code'] = trackDict.get('code', '')
						_rosterDict[_prefix + '_track_descr'] = trackDict.get('descr', '')
						metaTrackId = trackDict.get('metatrack_id', None)
						if metaTrackId:
							metaTrackDict = self.metaTrackCache.get(metaTrackId, None)
							if metaTrackDict:
								_rosterDict[_prefix + '_metatrack_code'] = metaTrackDict.get('code', '')
								_rosterDict[_prefix + '_metatrack_descr'] = metaTrackDict.get('descr', '')
								_rosterDict[_prefix + '_metatrack_supplemental'] = metaTrackDict.get('supplemental', False)

	def _assignName(self, _rosterDict):
		return stringUtils.constructLastCommaFirstName(_rosterDict.get('first_name', ''), _rosterDict.get('last_name', ''))


	#   Main method to trim Roster data.
	#   Accepts a Roster List as generated by getRoster()
	#   Returns a List with unnecessary crap removed.

	def trimRoster(self, _phatRoster):
		roster = []
		for phatEntry in _phatRoster:
			roster.append(self._trimPhatRosterEntry(phatEntry))
		return roster

	def _trimPhatRosterEntry(self, _phatEntry):
		newDict = self._extractKeys(_phatEntry, ["department_descr","is_primary","pcn","pcn_url","position_id"])
		newDict['appointment_list'] = []
		for phatApptDict in _phatEntry.get('appointment_list', []):
			newApptDict = self._extractKeys(phatApptDict, ["actionable","appointment_id","department_code","department_descr","display_name","is_primary","jobaction_id","metatrack_supplemental","person_id","person_url","pcn","pcn_url","position_id","status_descr","time_in_rank_display","time_in_rank_months","title_descr","track_descr"])
			newApptDict['job_action_list'] = []
			for phatJobActionDict in phatApptDict.get('job_action_list', []):
				newJobActionDict = self._extractKeys(phatJobActionDict, ["countdown_days","department_descr","is_primary","job_action_id","job_action_updated","job_action_status","job_action_type_descr","job_action_url","metatrack_supplemental","pcn","pcn_url","person_id","person_url","position_id","proposed_start_date","status_descr","title_descr","track_descr"])
				newApptDict['job_action_list'].append(newJobActionDict)
			newDict['appointment_list'].append(newApptDict)
		return newDict

	def _extractKeys(self, _srcDict, _keyList):
		newDict = {}
		for keyName in _keyList:
			if keyName in _srcDict:
				newDict[keyName] = _srcDict[keyName]
		return newDict
